#summary Byte-level Description of the MGA binary file.
#labels Phase-Implementation

= Introduction =

Below is the byte-level description of the MGA binary file format.  This will change depending on the work being done regarding changes to the MGA "special sauce" and the binary format itself, as described in [MGA_v2_to_v3_Changes].

= MGA Binary File Format - Version 3 =

Bytes (all ordered little endian):

0-15: Uuid (16 bytes) - The Uuid of the corresponding !MetaProject.

16-19: Size of Index (4 bytes as uint32_t)

20-35: Uuid(16 bytes) - The Uuid of the root object for this project.

== Index Entries (Each) ==
  * Uuid (16 bytes)
  * File Position (8 bytes - uin64_t)
  * Object Size (4 bytes - uint32_t)

=== Start of Objects ===

0-1: MetaID (2 bytes - MetaID_t)<br>

=== Start of Attributes (within an Object) ===

0-1: !ValueType (1 byte - uint8_t)<br>
2-3: AttrID (2 bytes - AttrID_t)<br>

-- Read Attribute Value
  * Long: 4 bytes - int32_t
  * Real: 8 bytes - double
  * String: 4 bytes for length (uint32_t) + length number of bytes
  * !LongPointer: 16 bytes (Uuid)
  * Collection: 4 bytes size (uint32_t) + 16 bytes (Uuid) per item in collection
  * Pointer: 16 bytes (Uuid)

=== End of Attributes when !ValueType equals VALUETYPE_NONE ===

== End of Objects ==

= Loading a v3 MGA File =

Files are loaded via the !BinFile::Load() method.  One fstream read is performed to get the first 20 bytes of the file.  This will get the Uuid and size of the Index.  The Uuid is compared to that of the !CoreMetaProject passed in.  The number of objects in the index is passed to !BinFile::!ReadIndex() which calculates the size of the index and performs a single read to read in the entire index.  All reading after this is done on a per-object basis.

= MGA File Limitations =

There should be as few limitations as possible with the new v3 file format.  Here are a couple that I know of:

  * Max File Size: 64-bit addressing (16 million terabytes - really big)
  * Max Number of Objects: 32-bit (4.2 billion objects)